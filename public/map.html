<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ê²½ë¡œ ì°¾ê¸° - ì£¼ì†Œ ì…ë ¥ ë° ì§€ë„ í´ë¦­</title>
  <!-- ë„¤ì´ë²„ ì§€ë„ API ë¡œë“œ (geocoder, directions ëª¨ë“ˆ í¬í•¨) -->
  <script src="https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=id0ukwormz&submodules=geocoder,directions"></script>
  <!-- Google Maps JavaScript API (Places ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬í•¨) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBLFKT4csgikH-xFcNh2-yKVk2rS5G6uYQ&libraries=places"></script>
  <style>
    /* ì§€ë„ ì˜ì—­ì˜ í¬ê¸° ì„¤ì • */
    #map {
      width: 50%;
      height: 400px;
      margin-top: 20px;
    }
    .section {
      margin: 20px 0;
    }
    /* ì£¼ì†Œ ë° ê²½ë¡œ ì •ë³´ í‘œì‹œ ì˜ì—­ ìŠ¤íƒ€ì¼ */
    #addressDisplay, #routeSummary {
      font-size: 16px;
      margin-top: 10px;
    }
    #addressDisplay p, #routeSummary p {
      margin: 4px 0;
    }
  </style>
</head>
<body>
  <h1>ê²½ë¡œ ì°¾ê¸°</h1>

  <!-- ì£¼ì†Œ ì…ë ¥ ë°©ì‹ ì„¹ì…˜ -->
  <div class="section">
    <h2>ì£¼ì†Œ ì…ë ¥ (ì˜ˆ: ê°•ë‚¨êµ¬ì²­, ì¶˜ì²œì‹œì²­)</h2>
    <form id="addressForm">
      <label for="startAddress">ì¶œë°œì§€:</label>
      <input type="text" id="startAddress" name="start" placeholder="ì˜ˆ: ê°•ë‚¨êµ¬ì²­" required>
      <br><br>
      <label for="endAddress">ëª©ì ì§€:</label>
      <input type="text" id="endAddress" name="end" placeholder="ì˜ˆ: ì¶˜ì²œì‹œì²­" required>
      <br><br>
      <button type="submit">ê²½ë¡œ ì°¾ê¸°</button>
    </form>
  </div>

  <!-- ì§€ë„ í´ë¦­ ë°©ì‹ ì„¹ì…˜ (ì„ íƒ ì‚¬í•­) -->
  <div class="section">
    <h2>ì§€ë„ í´ë¦­ ì„ íƒ</h2>
    <p>ì§€ë„ì—ì„œ ì²« ë²ˆì§¸ í´ë¦­: ì¶œë°œì§€, ë‘ ë²ˆì§¸ í´ë¦­: ëª©ì ì§€ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.</p>
  </div>

  <!-- ì§€ë„ ë° ë¦¬ì…‹ ë²„íŠ¼ -->
  <button id="resetBtn">ì´ˆê¸°í™”</button>
  <div id="map"></div>

  <!-- ì„ íƒëœ ì£¼ì†Œë¥¼ í‘œì‹œí•˜ëŠ” ì˜ì—­ -->
  <div class="section" id="addressDisplay">
    <h2>ì„ íƒëœ ì£¼ì†Œ</h2>
    <p id="startAddressDisplay">ì¶œë°œì§€ ì£¼ì†Œ: ì—†ìŒ</p>
    <p id="endAddressDisplay">ë„ì°©ì§€ ì£¼ì†Œ: ì—†ìŒ</p>
  </div>

  <!-- ê²½ë¡œ ì •ë³´ë¥¼ í‘œì‹œí•˜ëŠ” ì˜ì—­ -->
  <div class="section" id="routeSummary">
    <h2>ê²½ë¡œ ì •ë³´</h2>
    <p id="durationInfo">ì´ ì†Œìš”ì‹œê°„: ì—†ìŒ</p>
    <p id="distanceInfo">ì´ ì´ë™ê±°ë¦¬: ì—†ìŒ</p>
  </div>

  <script>
    // Google API í‚¤ (êµìœ¡ìš© í”„ë¡œì íŠ¸ìš©)
    const googleApiKey = "AIzaSyBLFKT4csgikH-xFcNh2-yKVk2rS5G6uYQ";

    // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
    let map;
    let startMarker = null;
    let endMarker = null;
    let polyline = null;
    let startPoint = null;
    let endPoint = null;
    let restaurantMarkers = [];
    let currentInfoWindow = null;

    // Autocomplete ê´€ë ¨ ë³€ìˆ˜ (ìë™ì™„ì„± ê²°ê³¼ ì €ì¥)
    let startAutocomplete, endAutocomplete;
    let startPlaceFromAuto = null;
    let endPlaceFromAuto = null;

    // ì§€ë„ ì´ˆê¸°í™” (ë„¤ì´ë²„ ì§€ë„)
    function initMap() {
      const mapOptions = {
        center: new naver.maps.LatLng(37.5665, 126.9780),
        zoom: 15
      };
      map = new naver.maps.Map('map', mapOptions);

      // ì§€ë„ í´ë¦­ ì´ë²¤íŠ¸ (ìë™ì™„ì„± ì™¸ì˜ ë°©ì‹ìœ¼ë¡œ ì„ íƒ ì‹œ ì‚¬ìš©)
      naver.maps.Event.addListener(map, 'click', function(e) {
        const clickedPoint = { lat: e.coord.lat(), lng: e.coord.lng() };
        if (!startPoint) {
          startPoint = clickedPoint;
          startMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(startPoint.lat, startPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid green; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: green;">ì¶œë°œ</div>`
            }
          });
          updateAddressDisplay(startPoint, 'startAddressDisplay');
          alert("ì¶œë°œì§€ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ í´ë¦­í•˜ì—¬ ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
        } else if (!endPoint) {
          endPoint = clickedPoint;
          endMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(endPoint.lat, endPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid red; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: red;">ë„ì°©</div>`
            }
          });
          updateAddressDisplay(endPoint, 'endAddressDisplay');
          fetchRoute();
        }
      });
    }

    /**
     * Autocomplete ì´ˆê¸°í™” í•¨ìˆ˜
     * - ì‚¬ìš©ìê°€ ìë™ì™„ì„± ì œì•ˆì„ ì„ íƒí•˜ë©´ í•´ë‹¹ ê²°ê³¼ë¥¼ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥í•©ë‹ˆë‹¤.
     */
    function initAutocomplete() {
      const startInput = document.getElementById('startAddress');
      const endInput = document.getElementById('endAddress');

      startAutocomplete = new google.maps.places.Autocomplete(startInput, { types: ['geocode', 'establishment'] });
      endAutocomplete = new google.maps.places.Autocomplete(endInput, { types: ['geocode', 'establishment'] });

      startAutocomplete.addListener('place_changed', function() {
        const place = startAutocomplete.getPlace();
        if (place && place.geometry) {
          startPlaceFromAuto = place;
        } else {
          startPlaceFromAuto = null;
        }
      });

      endAutocomplete.addListener('place_changed', function() {
        const place = endAutocomplete.getPlace();
        if (place && place.geometry) {
          endPlaceFromAuto = place;
        } else {
          endPlaceFromAuto = null;
        }
      });
    }

    /**
     * findPlaceByText í•¨ìˆ˜
     * - Google PlacesServiceì˜ findPlaceFromQuery ë©”ì„œë“œë¥¼ ì´ìš©í•´
     *   ì‚¬ìš©ìê°€ ì…ë ¥í•œ í…ìŠ¤íŠ¸ë¡œ ì¥ì†Œ ê²€ìƒ‰ì„ ìˆ˜í–‰í•˜ê³  ì²« ë²ˆì§¸ ê²°ê³¼ë¥¼ callbackìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
     */
    function findPlaceByText(input, callback) {
      const service = new google.maps.places.PlacesService(document.createElement('div'));
      service.findPlaceFromQuery({
        query: input,
        fields: ['name', 'geometry', 'formatted_address']
      }, (results, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length > 0) {
          callback(results[0]);
        } else {
          alert('ì¥ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + input);
        }
      });
    }

    // ì—­ì§€ì˜¤ì½”ë”© (ë„¤ì´ë²„ API ì‚¬ìš©): ì¢Œí‘œë¥¼ ì‹¤ì œ ì£¼ì†Œë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
    function updateAddressDisplay(point, elementId) {
      naver.maps.Service.reverseGeocode({
        location: new naver.maps.LatLng(point.lat, point.lng)
      }, function(status, response) {
        if (status === naver.maps.Service.Status.OK) {
          const items = response.result.items;
          if (items && items.length > 0) {
            const address = items[0].address;
            document.getElementById(elementId).innerText =
              (elementId === 'startAddressDisplay' ? "ì¶œë°œì§€ ì£¼ì†Œ: " : "ë„ì°©ì§€ ì£¼ì†Œ: ") + address;
          } else {
            document.getElementById(elementId).innerText =
              (elementId === 'startAddressDisplay' ? "ì¶œë°œì§€ ì£¼ì†Œ: " : "ë„ì°©ì§€ ì£¼ì†Œ: ") + "ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ";
          }
        } else {
          document.getElementById(elementId).innerText =
            (elementId === 'startAddressDisplay' ? "ì¶œë°œì§€ ì£¼ì†Œ: " : "ë„ì°©ì§€ ì£¼ì†Œ: ") + "ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ";
        }
      });
    }

    /**
     * í¼ ì œì¶œ ì´ë²¤íŠ¸ ì²˜ë¦¬
     * - ë¨¼ì € ìë™ì™„ì„± ê²°ê³¼ê°€ ìˆë‹¤ë©´ ê·¸ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ê³ ,
     *   ì—†ìœ¼ë©´ findPlaceByTextë¥¼ í†µí•´ í…ìŠ¤íŠ¸ ê²€ìƒ‰ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
     */
    document.getElementById('addressForm').addEventListener('submit', function(e) {
      e.preventDefault();
      resetMap();

      const startInputText = document.getElementById('startAddress').value;
      const endInputText = document.getElementById('endAddress').value;

      // Promiseë¥¼ ì‚¬ìš©í•˜ì—¬ ë‘ ì…ë ¥ì— ëŒ€í•´ ì²˜ë¦¬
      const startPromise = new Promise((resolve, reject) => {
        if (startPlaceFromAuto && startPlaceFromAuto.geometry) {
          resolve(startPlaceFromAuto);
        } else {
          findPlaceByText(startInputText, function(place) {
            if (place) resolve(place);
            else reject('ì¶œë°œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          });
        }
      });

      const endPromise = new Promise((resolve, reject) => {
        if (endPlaceFromAuto && endPlaceFromAuto.geometry) {
          resolve(endPlaceFromAuto);
        } else {
          findPlaceByText(endInputText, function(place) {
            if (place) resolve(place);
            else reject('ëª©ì ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          });
        }
      });

      Promise.all([startPromise, endPromise])
        .then(results => {
          const startPlace = results[0];
          const endPlace = results[1];

          startPoint = {
            lat: startPlace.geometry.location.lat(),
            lng: startPlace.geometry.location.lng()
          };
          endPoint = {
            lat: endPlace.geometry.location.lat(),
            lng: endPlace.geometry.location.lng()
          };

          // ì¶œë°œì§€ ë§ˆì»¤ ìƒì„±
          startMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(startPoint.lat, startPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid green; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: green;">ì¶œë°œ</div>`
            }
          });
          updateAddressDisplay(startPoint, 'startAddressDisplay');

          // ëª©ì ì§€ ë§ˆì»¤ ìƒì„±
          endMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(endPoint.lat, endPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid red; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: red;">ë„ì°©</div>`
            }
          });
          updateAddressDisplay(endPoint, 'endAddressDisplay');

          // ê²½ë¡œ ìš”ì²­
          fetchRoute();
        })
        .catch(error => {
          alert(error);
        });
    });

    // ì„œë²„ì— ê²½ë¡œ ìš”ì²­ (ì¶œë°œì§€ì™€ ëª©ì ì§€ ì¢Œí‘œ ì „ë‹¬)
    function fetchRoute() {
      fetch('/get-route', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ start: startPoint, end: endPoint, mode: 'DRIVING' })
      })
      .then(response => response.json())
      .then(data => { drawRoute(data); })
      .catch(error => console.error('ê²½ë¡œ ìš”ì²­ ì‹¤íŒ¨:', error));
    }

    // ë‘ ì¢Œí‘œ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ë¯¸í„° ë‹¨ìœ„ë¡œ ê³„ì‚° (Haversine ê³µì‹)
    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371000; // ì§€êµ¬ ë°˜ì§€ë¦„ (ë¯¸í„°)
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // polylineì˜ ì¢Œí‘œ ë°°ì—´ì—ì„œ ì¼ì • ê°„ê²©(ì˜ˆ: 500m)ë§ˆë‹¤ ìƒ˜í”Œ ì¢Œí‘œ ì¶”ì¶œ
    function samplePointsByDistance(path, interval) {
      const samples = [];
      if (path.length === 0) return samples;
      let lastPoint = path[0];
      samples.push(lastPoint);
      let accumulatedDistance = 0;
      for (let i = 1; i < path.length; i++) {
        const currentPoint = path[i];
        const dist = getDistance(lastPoint.lat(), lastPoint.lng(), currentPoint.lat(), currentPoint.lng());
        accumulatedDistance += dist;
        if (accumulatedDistance >= interval) {
          samples.push(currentPoint);
          lastPoint = currentPoint;
          accumulatedDistance = 0;
        }
      }
      return samples;
    }

    // ì„œë²„ì—ì„œ ë°›ì€ ê²½ë¡œ ë°ì´í„°ë¥¼ ì§€ë„ì— í‘œì‹œí•˜ê³ , ê²½ë¡œ ìƒì˜ ë§›ì§‘ ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ì—¬ í‘œì‹œ
    function drawRoute(routeData) {
      if (!routeData || !routeData.route) {
        alert('ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      if (polyline) polyline.setMap(null);
      const traoptimal = routeData.route.traoptimal[0];
      const path = traoptimal.path.map(coord => new naver.maps.LatLng(coord[1], coord[0]));
      polyline = new naver.maps.Polyline({
        path: path,
        strokeColor: "#FF0000",
        strokeWeight: 5,
        map: map
      });
      const bounds = new naver.maps.LatLngBounds();
      path.forEach(coord => bounds.extend(coord));
      map.fitBounds(bounds);

      if (traoptimal.summary) {
        const durationInMilliseconds = traoptimal.summary.duration;
        const durationInSeconds = Math.floor(durationInMilliseconds / 1000);
        const minutes = Math.floor(durationInSeconds / 60);
        const seconds = durationInSeconds % 60;
        document.getElementById('durationInfo').innerText = `ì´ ì†Œìš”ì‹œê°„: ${minutes}ë¶„ ${seconds}ì´ˆ`;
        const distanceInMeters = traoptimal.summary.distance;
        const distanceInKm = (distanceInMeters / 1000).toFixed(1);
        document.getElementById('distanceInfo').innerText = `ì´ ì´ë™ê±°ë¦¬: ${distanceInKm} km (${distanceInMeters} m)`;
      } else {
        document.getElementById('durationInfo').innerText = "ì´ ì†Œìš”ì‹œê°„: ì •ë³´ ì—†ìŒ";
        document.getElementById('distanceInfo').innerText = "ì´ ì´ë™ê±°ë¦¬: ì •ë³´ ì—†ìŒ";
      }

      const samplePoints = samplePointsByDistance(path, 500);
      samplePoints.forEach(point => {
        fetch(`/get-restaurants?lat=${point.lat()}&lng=${point.lng()}`)
          .then(response => response.json())
          .then(data => {
            if (data.results && data.results.length > 0) {
              const sorted = data.results.sort((a, b) => {
                const ratingA = a.rating ? a.rating : 0;
                const ratingB = b.rating ? b.rating : 0;
                return ratingB - ratingA;
              });
              const top3 = sorted.slice(0, 0);
              top3.forEach(place => {
                const restaurantLatLng = new naver.maps.LatLng(place.geometry.location.lat, place.geometry.location.lng);
                const marker = new naver.maps.Marker({
                  position: restaurantLatLng,
                  map: map,
                  icon: {
                    content: `<div style="font-size: 18px;">ğŸ´</div>`
                  },
                  title: `${place.name} (í‰ì : ${place.rating ? place.rating : 'ì—†ìŒ'})`
                });
                const photoUrl = (place.photos && place.photos.length > 0)
                  ? `https://maps.googleapis.com/maps/api/place/photo?maxwidth=100&photoreference=${place.photos[0].photo_reference}&key=${googleApiKey}`
                  : "";
                let baseContent = `<div style="padding:10px;">
                                      <h4 style="margin:0;">${place.name}</h4>
                                      ${photoUrl ? `<img src="${photoUrl}" alt="${place.name}" style="width:100px;height:auto;margin:5px 0;"/>` : ""}
                                      <p style="margin:5px 0;">í‰ì : ${place.rating ? place.rating : 'ì •ë³´ ì—†ìŒ'}</p>
                                      <p style="margin:5px 0;">ì£¼ì†Œ: ${place.vicinity ? place.vicinity : 'ì •ë³´ ì—†ìŒ'}</p>
                                    </div>`;
                const infoWindow = new naver.maps.InfoWindow({ content: baseContent });
                const service = new google.maps.places.PlacesService(document.createElement('div'));
                service.getDetails({
                  placeId: place.place_id,
                  fields: ['formatted_phone_number', 'types', 'website', 'formatted_address']
                }, function(details, status) {
                  if (status === google.maps.places.PlacesServiceStatus.OK) {
                    let detailsHtml = "";
                    if (details.types) {
                      detailsHtml += `<p>ì¢…ë¥˜: ${details.types.join(', ')}</p>`;
                    }
                    if (details.formatted_phone_number) {
                      detailsHtml += `<p>ì—°ë½ì²˜: ${details.formatted_phone_number}</p>`;
                    }
                    if (details.website) {
                      detailsHtml += `<p>ì›¹ì‚¬ì´íŠ¸: <a href="${details.website}" target="_blank">${details.website}</a></p>`;
                    }
                    infoWindow.setContent(`<div style="padding:10px;">
                                                <h4 style="margin:0;">${place.name}</h4>
                                                ${photoUrl ? `<img src="${photoUrl}" alt="${place.name}" style="width:100px;height:auto;margin:5px 0;"/>` : ""}
                                                <p style="margin:5px 0;">í‰ì : ${place.rating ? place.rating : 'ì •ë³´ ì—†ìŒ'}</p>
                                                <p style="margin:5px 0;">ì£¼ì†Œ: ${place.vicinity ? place.vicinity : 'ì •ë³´ ì—†ìŒ'}</p>
                                                ${detailsHtml}
                                              </div>`);
                  } else {
                    console.error("Place Details API ì˜¤ë¥˜:", status);
                  }
                });
                naver.maps.Event.addListener(marker, 'click', function() {
                  if (currentInfoWindow) {
                    currentInfoWindow.close();
                  }
                  infoWindow.open(map, marker);
                  currentInfoWindow = infoWindow;
                });
                restaurantMarkers.push(marker);
              });
            }
          })
          .catch(err => console.error(err));
      });
    }

    // ESC í‚¤ ì´ë²¤íŠ¸: ì—´ë ¤ ìˆëŠ” ì¸í¬ìœˆë„ìš° ë‹«ê¸°
    document.addEventListener('keydown', function(e) {
      if (e.key === "Escape" || e.keyCode === 27) {
        if (currentInfoWindow) {
          currentInfoWindow.close();
          currentInfoWindow = null;
        }
      }
    });

    // ì´ˆê¸°í™” ë²„íŠ¼ ì´ë²¤íŠ¸: ì§€ë„ ë° í‘œì‹œëœ ì •ë³´ ì´ˆê¸°í™”
    document.getElementById('resetBtn').addEventListener('click', function() {
      resetMap();
      document.getElementById('addressForm').reset();
      document.getElementById('startAddressDisplay').innerText = "ì¶œë°œì§€ ì£¼ì†Œ: ì—†ìŒ";
      document.getElementById('endAddressDisplay').innerText = "ë„ì°©ì§€ ì£¼ì†Œ: ì—†ìŒ";
      document.getElementById('durationInfo').innerText = "ì´ ì†Œìš”ì‹œê°„: ì—†ìŒ";
      document.getElementById('distanceInfo').innerText = "ì´ ì´ë™ê±°ë¦¬: ì—†ìŒ";
      console.log("ì¶œë°œì§€ ì£¼ì†Œ:", document.getElementById('startAddressDisplay').innerText);
      console.log("ë„ì°©ì§€ ì£¼ì†Œ:", document.getElementById('endAddressDisplay').innerText);
      console.log("ì´ ì†Œìš”ì‹œê°„:", document.getElementById('durationInfo').innerText);
      console.log("ì´ ì´ë™ê±°ë¦¬:", document.getElementById('distanceInfo').innerText);
    });

    // ì§€ë„ ë° ê´€ë ¨ ë³€ìˆ˜ ì´ˆê¸°í™” í•¨ìˆ˜
    function resetMap() {
      startPoint = null;
      endPoint = null;
      if (startMarker) {
        startMarker.setMap(null);
        startMarker = null;
      }
      if (endMarker) {
        endMarker.setMap(null);
        endMarker = null;
      }
      if (polyline) {
        polyline.setMap(null);
        polyline = null;
      }
      restaurantMarkers.forEach(marker => marker.setMap(null));
      restaurantMarkers = [];
      currentInfoWindow = null;
    }

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì‹¤í–‰: ì§€ë„ì™€ Autocomplete ì´ˆê¸°í™” (ìë™ì™„ì„±ê³¼ í…ìŠ¤íŠ¸ ê²€ìƒ‰ ë‘˜ ë‹¤ ì‚¬ìš©)
    window.onload = function() {
      initMap();
      initAutocomplete();
    };
  </script>
</body>
</html>
