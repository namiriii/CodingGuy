<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ê²½ë¡œ ì°¾ê¸° - ì£¼ì†Œ ì…ë ¥ ë° ì§€ë„ í´ë¦­</title>
  <!-- ë„¤ì´ë²„ ì§€ë„ API ë¡œë“œ (geocoder, directions ëª¨ë“ˆ í¬í•¨) -->
  <script src="https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=id0ukwormz&submodules=geocoder,directions"></script>
  <!-- Google Maps JavaScript API (Places ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬í•¨) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBLFKT4csgikH-xFcNh2-yKVk2rS5G6uYQ&libraries=places"></script>
  <style>
    /* ì§€ë„ ì˜ì—­ì˜ í¬ê¸° ì„¤ì • */
    #map {
      width: 50%;
      height: 400px;
      margin-top: 20px;
    }
    .section {
      margin: 20px 0;
    }
    /* ì£¼ì†Œ ë° ê²½ë¡œ ì •ë³´ í‘œì‹œ ì˜ì—­ ìŠ¤íƒ€ì¼ */
    #addressDisplay, #routeSummary {
      font-size: 16px;
      margin-top: 10px;
    }
    #addressDisplay p, #routeSummary p {
      margin: 4px 0;
    }
  </style>
</head>
<body>
  <h1>ê²½ë¡œ ì°¾ê¸°</h1>

  <!-- ì£¼ì†Œ ì…ë ¥ ë°©ì‹ ì„¹ì…˜ -->
  <div class="section">
    <h2>ì£¼ì†Œ ì…ë ¥ (ì˜ˆ: ê°•ë‚¨êµ¬ì²­, ì¶˜ì²œì‹œì²­)</h2>
    <form id="addressForm">
      <label for="startAddress">ì¶œë°œì§€:</label>
      <input type="text" id="startAddress" name="start" placeholder="ì˜ˆ: ê°•ë‚¨êµ¬ì²­" required>
      <br><br>
      <label for="endAddress">ëª©ì ì§€:</label>
      <input type="text" id="endAddress" name="end" placeholder="ì˜ˆ: ì¶˜ì²œì‹œì²­" required>
      <br><br>
      <button type="submit">ê²½ë¡œ ì°¾ê¸°</button>
    </form>
  </div>

  <!-- ì§€ë„ í´ë¦­ ë°©ì‹ ì„¹ì…˜ (ì„ íƒ ì‚¬í•­) -->
  <div class="section">
    <h2>ì§€ë„ í´ë¦­ ì„ íƒ</h2>
    <p>ì§€ë„ì—ì„œ ì²« ë²ˆì§¸ í´ë¦­: ì¶œë°œì§€, ë‘ ë²ˆì§¸ í´ë¦­: ëª©ì ì§€ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.</p>
  </div>

  <!-- ì§€ë„ ë° ë¦¬ì…‹ ë²„íŠ¼ -->
  <button id="resetBtn">ì´ˆê¸°í™”</button>
  <div id="map"></div>

  <!-- ì„ íƒëœ ì£¼ì†Œë¥¼ í‘œì‹œí•˜ëŠ” ì˜ì—­ -->
  <div class="section" id="addressDisplay">
    <h2>ì„ íƒëœ ì£¼ì†Œ</h2>
    <p id="startAddressDisplay">ì¶œë°œì§€ ì£¼ì†Œ: ì—†ìŒ</p>
    <p id="endAddressDisplay">ë„ì°©ì§€ ì£¼ì†Œ: ì—†ìŒ</p>
  </div>

  <!-- ê²½ë¡œ ì •ë³´ë¥¼ í‘œì‹œí•˜ëŠ” ì˜ì—­ -->
  <div class="section" id="routeSummary">
    <h2>ê²½ë¡œ ì •ë³´</h2>
    <p id="durationInfo">ì´ ì†Œìš”ì‹œê°„: ì—†ìŒ</p>
    <p id="distanceInfo">ì´ ì´ë™ê±°ë¦¬: ì—†ìŒ</p>
  </div>

  <script>
    // Google API í‚¤ (êµìœ¡ìš© í”„ë¡œì íŠ¸ìš©)
    const googleApiKey = "AIzaSyBLFKT4csgikH-xFcNh2-yKVk2rS5G6uYQ";

    // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
    let map;
    let startMarker = null;
    let endMarker = null;
    let polyline = null;
    let startPoint = null;
    let endPoint = null;
    let restaurantMarkers = [];
    let currentInfoWindow = null;

    // Autocomplete ê´€ë ¨ ë³€ìˆ˜
    let startAutocomplete, endAutocomplete;
    let startPlaceFromAuto = null;
    let endPlaceFromAuto = null;

    // ì§€ë„ ì´ˆê¸°í™” (ë„¤ì´ë²„ ì§€ë„)
    function initMap() {
      const mapOptions = {
        center: new naver.maps.LatLng(37.5665, 126.9780),
        zoom: 15
      };
      map = new naver.maps.Map('map', mapOptions);

      // ì§€ë„ í´ë¦­ ì´ë²¤íŠ¸ (ìˆ˜ë™ ì„ íƒ)
      naver.maps.Event.addListener(map, 'click', function(e) {
        const clickedPoint = { lat: e.coord.lat(), lng: e.coord.lng() };
        if (!startPoint) {
          startPoint = clickedPoint;
          startMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(startPoint.lat, startPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid green; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: green;">ì¶œë°œ</div>`
            }
          });
          updateAddressDisplay(startPoint, 'startAddressDisplay');
          alert("ì¶œë°œì§€ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ í´ë¦­í•˜ì—¬ ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
        } else if (!endPoint) {
          endPoint = clickedPoint;
          endMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(endPoint.lat, endPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid red; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: red;">ë„ì°©</div>`
            }
          });
          updateAddressDisplay(endPoint, 'endAddressDisplay');
          fetchRoute();
        }
      });
    }

    // Autocomplete ì´ˆê¸°í™”
    function initAutocomplete() {
      const startInput = document.getElementById('startAddress');
      const endInput = document.getElementById('endAddress');

      startAutocomplete = new google.maps.places.Autocomplete(startInput, { types: ['geocode', 'establishment'] });
      endAutocomplete = new google.maps.places.Autocomplete(endInput, { types: ['geocode', 'establishment'] });

      startAutocomplete.addListener('place_changed', function() {
        const place = startAutocomplete.getPlace();
        startPlaceFromAuto = (place && place.geometry) ? place : null;
      });

      endAutocomplete.addListener('place_changed', function() {
        const place = endAutocomplete.getPlace();
        endPlaceFromAuto = (place && place.geometry) ? place : null;
      });
    }

    // í…ìŠ¤íŠ¸ ê¸°ë°˜ ì¥ì†Œ ê²€ìƒ‰
    function findPlaceByText(input, callback) {
      const service = new google.maps.places.PlacesService(document.createElement('div'));
      service.findPlaceFromQuery({
        query: input,
        fields: ['name', 'geometry', 'formatted_address']
      }, (results, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length > 0) {
          callback(results[0]);
        } else {
          alert('ì¥ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + input);
        }
      });
    }

    // ì—­ì§€ì˜¤ì½”ë”© (ë„¤ì´ë²„ API ì‚¬ìš©)
    function updateAddressDisplay(point, elementId) {
      naver.maps.Service.reverseGeocode({
        location: new naver.maps.LatLng(point.lat, point.lng)
      }, function(status, response) {
        let displayText = (elementId === 'startAddressDisplay') ? "ì¶œë°œì§€ ì£¼ì†Œ: " : "ë„ì°©ì§€ ì£¼ì†Œ: ";
        if (status === naver.maps.Service.Status.OK) {
          const items = response.result.items;
          displayText += (items && items.length > 0) ? items[0].address : "ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ";
        } else {
          displayText += "ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ";
        }
        document.getElementById(elementId).innerText = displayText;
      });
    }

    // í¼ ì œì¶œ ì´ë²¤íŠ¸ ì²˜ë¦¬
    document.getElementById('addressForm').addEventListener('submit', function(e) {
      e.preventDefault();
      resetMap();

      const startInputText = document.getElementById('startAddress').value;
      const endInputText = document.getElementById('endAddress').value;

      const startPromise = new Promise((resolve, reject) => {
        if (startPlaceFromAuto && startPlaceFromAuto.geometry) {
          resolve(startPlaceFromAuto);
        } else {
          findPlaceByText(startInputText, function(place) {
            place ? resolve(place) : reject('ì¶œë°œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          });
        }
      });

      const endPromise = new Promise((resolve, reject) => {
        if (endPlaceFromAuto && endPlaceFromAuto.geometry) {
          resolve(endPlaceFromAuto);
        } else {
          findPlaceByText(endInputText, function(place) {
            place ? resolve(place) : reject('ëª©ì ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          });
        }
      });

      Promise.all([startPromise, endPromise])
        .then(results => {
          const [startPlace, endPlace] = results;
          startPoint = {
            lat: startPlace.geometry.location.lat(),
            lng: startPlace.geometry.location.lng()
          };
          endPoint = {
            lat: endPlace.geometry.location.lat(),
            lng: endPlace.geometry.location.lng()
          };

          // ì¶œë°œì§€/ë„ì°©ì§€ ë§ˆì»¤ í‘œì‹œ
          startMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(startPoint.lat, startPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid green; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: green;">ì¶œë°œ</div>`
            }
          });
          updateAddressDisplay(startPoint, 'startAddressDisplay');

          endMarker = new naver.maps.Marker({
            position: new naver.maps.LatLng(endPoint.lat, endPoint.lng),
            map: map,
            animation: naver.maps.Animation.DROP,
            icon: {
              content: `<div style="background: white; border: 2px solid red; border-radius: 50%; width: 40px; height: 40px;
                        display: flex; align-items: center; justify-content: center; font-weight: bold; color: red;">ë„ì°©</div>`
            }
          });
          updateAddressDisplay(endPoint, 'endAddressDisplay');

          fetchRoute();
        })
        .catch(error => {
          alert(error);
        });
    });

    // ì„œë²„ì— ê²½ë¡œ ìš”ì²­ (ì¶œë°œì§€ì™€ ëª©ì ì§€ ì¢Œí‘œ ì „ë‹¬)
    function fetchRoute() {
      fetch('/get-route', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ start: startPoint, end: endPoint, mode: 'DRIVING' })
      })
      .then(response => response.json())
      .then(data => { drawRoute(data); })
      .catch(error => console.error('ê²½ë¡œ ìš”ì²­ ì‹¤íŒ¨:', error));
    }

    // Haversine ê³µì‹ìœ¼ë¡œ ë‘ ì¢Œí‘œ ê°„ ê±°ë¦¬(ë¯¸í„°) ê³„ì‚°
    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // â”€â”€ ê²½ë¡œ ë¶„í• ì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // ì „ì²´ ê²½ë¡œ ê¸¸ì´ ê³„ì‚°
    function getTotalRouteLength(path) {
      let total = 0;
      for (let i = 0; i < path.length - 1; i++) {
        total += getDistance(path[i].lat(), path[i].lng(), path[i+1].lat(), path[i+1].lng());
      }
      return total;
    }

    // ëˆ„ì  ê±°ë¦¬ targetDistanceì— í•´ë‹¹í•˜ëŠ” ì¢Œí‘œ (ì„ í˜• ë³´ê°„)
    function getPointAtDistance(path, targetDistance) {
      let accumulated = 0;
      for (let i = 0; i < path.length - 1; i++) {
        const p1 = path[i];
        const p2 = path[i+1];
        const segmentDist = getDistance(p1.lat(), p1.lng(), p2.lat(), p2.lng());
        if (accumulated + segmentDist >= targetDistance) {
          const fraction = (targetDistance - accumulated) / segmentDist;
          const lat = p1.lat() + (p2.lat() - p1.lat()) * fraction;
          const lng = p1.lng() + (p2.lng() - p1.lng()) * fraction;
          return new naver.maps.LatLng(lat, lng);
        }
        accumulated += segmentDist;
      }
      return path[path.length - 1];
    }

    // â”€â”€ ê° êµ¬ê°„ì—ì„œ ìŒì‹ì  1ê°œì”© ê²€ìƒ‰í•˜ëŠ” í—¬í¼ í•¨ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì£¼ì–´ì§„ candidate pointì—ì„œ ê¸°ë³¸ ë°˜ê²½ 250më¶€í„° ìµœëŒ€ 1000mê¹Œì§€ ìˆœì°¨ì ìœ¼ë¡œ ì‹œë„í•˜ì—¬
    // ìµœì†Œí•œ í•˜ë‚˜ì˜ ìŒì‹ì (ìµœê³  í‰ì )ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
    function fetchOneRestaurantForPoint(point) {
      const radii = [250, 500, 750, 1000];
      let index = 0;
      function tryNext() {
        if (index >= radii.length) {
          return Promise.resolve(null);
        }
        const currentRadius = radii[index++];
        return fetch(`/get-restaurants?lat=${point.lat()}&lng=${point.lng()}&radius=${currentRadius}`)
          .then(response => response.json())
          .then(data => {
            const results = data.results ? data.results : [];
            if (results.length > 0) {
              results.sort((a, b) => (b.rating || 0) - (a.rating || 0));
              return results[0];
            } else {
              return tryNext();
            }
          })
          .catch(() => {
            return tryNext();
          });
      }
      return tryNext();
    }

    // â”€â”€ ê° êµ¬ê°„ì—ì„œ 1ê°œì”© ìŒì‹ì  ì„ íƒ (ì „ì²´ ê²½ë¡œë¥¼ në“±ë¶„) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì—¬ê¸°ì„œëŠ” candidatePointsë¥¼ ì „ì²´ ê²½ë¡œ ê¸¸ì´ë¥¼ në“±ë¶„í•˜ì—¬ êµ¬í•œ ê° êµ¬ê°„ ì¤‘ì•™ ì¢Œí‘œë¡œ ì„¤ì •
    // ê° êµ¬ê°„ë§ˆë‹¤ fetchOneRestaurantForPointë¥¼ í˜¸ì¶œí•˜ì—¬ ìµœëŒ€í•œ ìŒì‹ì  1ê°œì”©ì„ í™•ë³´
    function drawRoute(routeData) {
      if (!routeData || !routeData.route) {
        alert('ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      if (polyline) polyline.setMap(null);
      
      const traoptimal = routeData.route.traoptimal[0];
      const path = traoptimal.path.map(coord => new naver.maps.LatLng(coord[1], coord[0]));
      
      // ê²½ë¡œ(í´ë¦¬ë¼ì¸) ê·¸ë¦¬ê¸°
      polyline = new naver.maps.Polyline({
        path: path,
        strokeColor: "#FF0000",
        strokeWeight: 5,
        map: map
      });
      const bounds = new naver.maps.LatLngBounds();
      path.forEach(coord => bounds.extend(coord));
      map.fitBounds(bounds);

      // ê²½ë¡œ ìš”ì•½ ì •ë³´ í‘œì‹œ
      if (traoptimal.summary) {
        const durationInSeconds = Math.floor(traoptimal.summary.duration / 1000);
        const minutes = Math.floor(durationInSeconds / 60);
        const seconds = durationInSeconds % 60;
        document.getElementById('durationInfo').innerText = `ì´ ì†Œìš”ì‹œê°„: ${minutes}ë¶„ ${seconds}ì´ˆ`;
        const distanceInMeters = traoptimal.summary.distance;
        const distanceInKm = (distanceInMeters / 1000).toFixed(1);
        document.getElementById('distanceInfo').innerText = `ì´ ì´ë™ê±°ë¦¬: ${distanceInKm} km (${distanceInMeters} m)`;
      } else {
        document.getElementById('durationInfo').innerText = "ì´ ì†Œìš”ì‹œê°„: ì •ë³´ ì—†ìŒ";
        document.getElementById('distanceInfo').innerText = "ì´ ì´ë™ê±°ë¦¬: ì •ë³´ ì—†ìŒ";
      }

      // ì „ì²´ ê²½ë¡œë¥¼ në“±ë¶„ (ì—¬ê¸°ì„œëŠ” segmentCount ë³€ìˆ˜ë¡œ êµ¬ê°„ ìˆ˜ ì¡°ì ˆ)
      const segmentCount = 7; // ì˜ˆë¥¼ ë“¤ì–´ 7ê°œ êµ¬ê°„
      const totalLength = getTotalRouteLength(path);
      const segmentLength = totalLength / segmentCount;
      const candidatePoints = [];
      for (let i = 0; i < segmentCount; i++) {
        let targetDistance = (segmentLength / 2) + i * segmentLength;
        if (targetDistance > totalLength) targetDistance = totalLength;
        candidatePoints.push(getPointAtDistance(path, targetDistance));
      }

      // ê° candidate pointë§ˆë‹¤ ìŒì‹ì  1ê°œì”© ê²€ìƒ‰ (ê° êµ¬ê°„ì—ì„œ ë°˜ë“œì‹œ ìµœëŒ€í•œ 1ê°œì”© ë°˜í™˜)
      const candidatePromises = candidatePoints.map(point => fetchOneRestaurantForPoint(point));
      
      Promise.all(candidatePromises)
        .then(restaurants => {
          // restaurants ë°°ì—´ì˜ ê° ìš”ì†ŒëŠ” í•´ë‹¹ êµ¬ê°„ì—ì„œ ì„ íƒëœ ìŒì‹ì (ì—†ìœ¼ë©´ null)
          restaurants.forEach(place => {
            if (place) {
              const restaurantLatLng = new naver.maps.LatLng(
                place.geometry.location.lat,
                place.geometry.location.lng
              );
              const marker = new naver.maps.Marker({
                position: restaurantLatLng,
                map: map,
                icon: {
                  content: `<div style="background: red; color: white; border-radius: 50%; width: 30px; height: 30px;
                            display: flex; align-items: center; justify-content: center; font-weight: bold;">ğŸ´</div>`
                },
                title: `${place.name} (í‰ì : ${place.rating ? place.rating : 'ì—†ìŒ'})`
              });
              // ì¸í¬ìœˆë„ìš° êµ¬ì„± (ìŒì‹ì  ì‚¬ì§„, ì´ë¦„, í‰ì , ì£¼ì†Œ)
              const photoUrl = (place.photos && place.photos.length > 0)
                ? `https://maps.googleapis.com/maps/api/place/photo?maxwidth=100&photoreference=${place.photos[0].photo_reference}&key=${googleApiKey}`
                : "";
              const contentString = `<div style="padding:10px;">
                <h4 style="margin:0;">${place.name}</h4>
                ${photoUrl ? `<img src="${photoUrl}" alt="${place.name}" style="width:100px;height:auto;margin:5px 0;"/>` : ""}
                <p style="margin:5px 0;">í‰ì : ${place.rating ? place.rating : 'ì •ë³´ ì—†ìŒ'}</p>
                <p style="margin:5px 0;">ì£¼ì†Œ: ${place.vicinity ? place.vicinity : 'ì •ë³´ ì—†ìŒ'}</p>
              </div>`;
              const infoWindow = new naver.maps.InfoWindow({ content: contentString });
              naver.maps.Event.addListener(marker, 'click', function() {
                if (currentInfoWindow) {
                  currentInfoWindow.close();
                }
                infoWindow.open(map, marker);
                currentInfoWindow = infoWindow;
              });
              restaurantMarkers.push(marker);
            }
          });
        })
        .catch(err => console.error(err));
    }

    // ESC í‚¤ ì´ë²¤íŠ¸: ì¸í¬ìœˆë„ìš° ë‹«ê¸°
    document.addEventListener('keydown', function(e) {
      if (e.key === "Escape" || e.keyCode === 27) {
        if (currentInfoWindow) {
          currentInfoWindow.close();
          currentInfoWindow = null;
        }
      }
    });

    // ì´ˆê¸°í™” ë²„íŠ¼ ì´ë²¤íŠ¸: ì§€ë„ ë° ì •ë³´ ì´ˆê¸°í™”
    document.getElementById('resetBtn').addEventListener('click', function() {
      resetMap();
      document.getElementById('addressForm').reset();
      document.getElementById('startAddressDisplay').innerText = "ì¶œë°œì§€ ì£¼ì†Œ: ì—†ìŒ";
      document.getElementById('endAddressDisplay').innerText = "ë„ì°©ì§€ ì£¼ì†Œ: ì—†ìŒ";
      document.getElementById('durationInfo').innerText = "ì´ ì†Œìš”ì‹œê°„: ì—†ìŒ";
      document.getElementById('distanceInfo').innerText = "ì´ ì´ë™ê±°ë¦¬: ì—†ìŒ";
      console.log("ì¶œë°œì§€ ì£¼ì†Œ:", document.getElementById('startAddressDisplay').innerText);
      console.log("ë„ì°©ì§€ ì£¼ì†Œ:", document.getElementById('endAddressDisplay').innerText);
      console.log("ì´ ì†Œìš”ì‹œê°„:", document.getElementById('durationInfo').innerText);
      console.log("ì´ ì´ë™ê±°ë¦¬:", document.getElementById('distanceInfo').innerText);
    });

    // ì§€ë„ ë° ë³€ìˆ˜ ì´ˆê¸°í™”
    function resetMap() {
      startPoint = null;
      endPoint = null;
      if (startMarker) {
        startMarker.setMap(null);
        startMarker = null;
      }
      if (endMarker) {
        endMarker.setMap(null);
        endMarker = null;
      }
      if (polyline) {
        polyline.setMap(null);
        polyline = null;
      }
      restaurantMarkers.forEach(marker => marker.setMap(null));
      restaurantMarkers = [];
      currentInfoWindow = null;
    }

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.onload = function() {
      initMap();
      initAutocomplete();
    };
  </script>
</body>
</html>
